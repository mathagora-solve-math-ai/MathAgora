# Align 연구 조사

**멀티-스텝 출력 정렬(Alignment) 기법 정리**

## **1-A. 의미 기반(semantic) 정렬**

### **A-0) 의미 기반 정렬**

1. **Step 분할(step segmentation)**
    - 줄바꿈/번호(1., 2., …)/문장 단위/Step: 패턴 기반
    - 또는 LLM으로 “핵심 스텝만 리스트로 정규화” (아래 A-3 참고)
2. **Step 임베딩(embedding) 만들기**
    - 각 step 텍스트 → 임베딩 벡터
3. **Step 간 유사도(similarity) 계산**
    - 기본: cosine similarity
    - 강화: NLI entailment(함의) / contradiction(모순) 라벨링
4. **정렬 알고리즘 적용**
    - nearest neighbor(가장 유사한 짝) / DP 시퀀스 정렬 / 전역 최적화 매칭 등

---

### **A-1) 문장 임베딩 유사도 매칭 (Cosine 기반)**

### **핵심 아이디어**

- step을 벡터로 바꾸고
- sim(step_i, step_j) = cosine(embed(step_i), embed(step_j))
- 유사도 행렬 S를 만들고 정렬/매칭 수행

### **실제로 많이 쓰는 매칭 전략 3종**

1. **비대칭 최근접 매칭(Asymmetric Nearest Neighbor)**
    - A의 각 step i에 대해 B에서 가장 유사한 step j*를 하나 붙임
        
        j* = argmax_j S[i,j]
        
    - 장점: 간단/빠름, A 기준으로 B를 정렬 UI에 좋음
    - 단점: 한쪽 step 여러 개가 같은 상대 step에 몰릴 수 있음(1:N)
2. **대칭화(Symmetrization)**
    - A→B, B→A 두 번 매칭을 만들고
        - 교집합만 남기거나(엄격)
        - 평균/최소/최대 같은 규칙으로 합치기(유연)
    - 목적: 서로 진짜로 붙는 쌍만 신뢰도 높게 선택
3. **전역 최적 1:1 매칭(Bipartite Matching / Hungarian 스타일)**
    - A-step과 B-step을 1:1로 최대 매칭
    - 목적: step 수가 비슷할 때 정렬 품질이 깔끔해짐
    - 단점: step 수가 많이 다르면 갭 처리(삽입/삭제)가 별도 필요

---

### **A-2) NLI 기반 매칭 (Entailment/Contradiction로 동치/포함 잡기)**

### **핵심 아이디어**

유사도만으로는 표현이 달라도 논리적으로 같은 단계를 놓칠 수 있음.

그래서 step pair (a,b)에 대해:

- NLI(a → b) : a가 b를 함의하는가?
- NLI(b → a) : b가 a를 함의하는가?

이를 이용해 step 관계를 라벨링:

- **동치(near-equivalent)**: 양방향 entailment
- **포함(요약/상세)**: 한쪽만 entailment
- **충돌/모순**: contradiction

### **정렬에 쓰는 방법**

- cosine으로 후보 top-k를 좁힌 뒤
- 후보들에 NLI를 적용해 **동치/포함 관계가 강한 쌍**을 최종 정렬 쌍으로 선택
    
    (= 효율 + 품질 둘 다 챙김)
    

---

### **A-3) Step 정규화(요약/표준화) 후 매칭 (RPD류 접근)**

### **왜 필요한가**

- 모델마다 step granularity가 다름
    
    (어떤 건 한 줄, 어떤 건 한 문단, 어떤 건 중간 계산을 다 적음)
    
- 그대로 맞추면 유사도/정렬이 불안정해짐

### **방법**

- 먼저 LLM을 사용해 각 풀이를 **핵심 스텝 리스트로 정규화**
    
    예:
    
    - 불필요한 수사 제거
    - 중복 제거
    - 핵심 중간결론/변형만 남기기
- 그 다음 정규화된 step들끼리 임베딩 매칭

### **대표적인 발산도 계산(정렬 + 차이 측정까지 연결)**

- 짧은 쪽 step 각각을 긴 쪽에서 가장 가까운 step에 붙이고(비대칭 NN)
- 그 최소 거리들을 평균내면 **경로 발산도(divergence)**로 쓸 수 있음
    
    → 발산도가 크면 **전략/경로가 다름** 표시 가능
    

---

### **A-4) 순서 제약이 필요한 경우: 시퀀스 정렬(DP, Needleman–Wunsch 스타일)**

### **언제 쓰나**

- UI에서 비슷한 step을 비슷한 높이(위치)에 놓고 싶을 때
- 즉, step 순서를 어느 정도 보존해야 할 때

### **핵심 아이디어**

- step들을 시퀀스로 보고
- 매칭 점수 = cosine(또는 NLI 점수)
- 갭(삽입/삭제) 비용을 주고
- DP로 전체 정렬을 구함

### **장점**

- 한쪽에만 있는 step이 **갭으로 자연스럽게 표현**됨
- 분기/우회 구간이 시각화에 잘 드러남

---

## **1-B. 구조(Structure) 기반 정렬: 그래프/트리로 보는 방식**

### **B-0) 구조 기반 정렬의 요지**

문장 단위 유사도만 쓰면 놓치는 것:

- 같은 의미라도 역할이 다른 step(예: 가정 vs 결론)
- step 순서가 크게 뒤섞인 경우
- 중간결론(subgoal) 단위로 겹치는데 문장 표현은 다른 경우

그래서 reasoning을 다음처럼 구조화:

- **노드(node)**: 원자적 주장/중간결론/중간 계산 결과
- **엣지(edge)**: 의존관계(“이 결과를 써서 다음 결론을 도출”)

---

### **B-1) DAG(Directed Acyclic Graph)로 만들기**

### **그래프 구성 방법(실무적으로 흔한 2가지)**

1. **텍스트 기반 DAG(Claim Graph)**
- 노드: 중간 주장/결론 문장
- 엣지: 이 문장이 다음 문장을 뒷받침
- 엣지 추출:
    - 규칙 기반: “따라서/그러므로”, “because”, “so” 같은 연결어
    - LLM 기반: “각 문장이 어떤 이전 문장들에 의존하는지”를 추출하는 프롬프트
1. **연산 기반 DAG(수학/코드에 특히 적합)**
- 노드: 중간값/식/변형된 식
- 엣지: 연산/변형(대입, 전개, 약분 등)
- 장점: 수학에 매우 강함(“같은 중간결론”을 잘 잡음)

### **Node Block(블록화) 아이디어**

- 너무 세밀하면 노이즈가 커지므로
- 연속적인 노드들을 “하나의 블록”으로 묶어 coarse alignment → 세부 정렬로 내려가는 2단계가 안정적

---

### **B-2) 공통 backbone 찾기: 최대 공통 부분(MCS / 공통 경로)**

### **핵심 아이디어**

- 여러 풀이 그래프들 사이에서 **공통으로 나타나는 부분 그래프**를 찾으면:
    - 공통 backbone = 대부분이 공유하는 핵심 논리
    - branch = 특정 run만 택한 우회/대체 전략
    - divergence point = backbone에서 branch로 빠지는 최초 지점

### **실제 구현에서의 선택지**

- **정확한 MCS**는 계산이 무거울 수 있어 근사/휴리스틱이 흔함
- 실무적으로는:
    - 먼저 node를 의미 기반으로 후보 매칭(임베딩/NLI)
    - 그 다음 구조 제약(선후관계/의존)을 만족하는 쌍만 남겨 공통 subgraph를 구성
        
        이 흐름이 많이 쓰임
        

---

### **B-3) 트리(Tree) 기반: 탐색/분기(ToT류) 또는 다중 샘플 경로 병합**

### **언제 쓰나**

- 아예 모델이 여러 분기를 생성하는(또는 샘플을 많이 뽑는) 상황에서
- “유사한 분기끼리 묶고” “서로 다른 분기는 분리”해야 할 때

### **대표 아이디어: 유사 노드 병합(semantic merging)**

- 각 노드를 임베딩으로 바꾼 뒤
- cosine threshold 이상이면 같은 클러스터로 병합
- 클러스터 대표(가장 점수 높은 노드)만 남기는 pruning도 가능

이렇게 하면 시각화에서:

- 비슷한 분기들을 접어서(hypernode) 깔끔하게 보여줄 수 있음

---

## **1-C. 스텝 단위 정렬/차이 측정 메트릭 (정렬 품질 + 경로 차이까지)**

### **C-0) 메트릭이 필요한 이유**

시각화에서 보통 필요해지는 값들:

- “이 step 쌍이 얼마나 같은가?” (pairwise similarity)
- “이 두 풀이가 전체적으로 얼마나 비슷한가?” (global similarity)
- “어디서부터 갈라지는가?” (local divergence / branch point)

---

### **C-1) 유사도 기반 전역 점수**

- 정렬된 step pair들의 유사도를 평균/최댓값/가중 평균으로 집계
- 예:
    - Cos-Mean / Cos-Max
    - NLI-Mean / NLI-Max
- 목적: “이 두 run은 대체로 같은 풀이인가?”를 빠르게 판단

---

### **C-2) 발산도(Divergence) 기반 점수 (RPD류)**

- 핵심 스텝 정규화(요약) 후
- 비대칭 최근접 매칭으로 “각 step의 최소거리”를 구하고
- 평균내면 “경로 발산도”가 됨

활용:

- 발산도 낮음: 같은 전략(블록 가까이, 같은 색)
- 발산도 높음: 다른 전략(별도 lane/branch로 분리)

---